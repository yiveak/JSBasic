# temp

把产生值的操作的代码片段称为表达式。按照字面含义编写的值（比如 22 或 "psychoanalysis" ）都是一个表达式。表达式可以包含其他表达式。

为了捕获和保存值，JavaScript 提供了一种称为绑定或变量的东西。当绑定指向某个值时，并不意味着它永远与该值绑定。 可以在现有的绑定上随时使用 `=` 运算符，将它们与当前值断开连接，并让它们指向一个新值。

你应该将绑定想象为触手，而不是盒子。 他们不包含值; 他们捕获值 - 两个绑定可以引用相同
的值。 程序只能访问它还在引用的值。 如果你请求一个空绑定的值，你会得到 undefined 值。



给定时间中存在的绑定及其值的集合称为环境。 当一个程序启动时，这个环境不是空的。 它总是包含作为语言标准一部分的绑定，并且在大多数情况下，它还具有一些绑定，提供与周围系统交互的方式。 

绑定可以用来保存任何数据，并用一个绑定名对其引用。而且在记录你的程序执行状态时十分有用。环境是一组定义好的绑定集合。JavaScript 的运行环境中总会包含一系列有用的标准绑定。

执行一个函数被称为调用，或应用它（invoke，call，apply）。

`console.log`实际上是一个表达式，它从 console 绑定所持有的值中检索 log 属性。

任何产生值的东西都是 JavaScript 中的表达式，这意味着可以在较大的表达式中使用函数调用。

 Number.isNaN 函数是一个标准的 JavaScript 函数，仅当它给出的参数是 NaN 时才返回 true 。 当你给它一个不代表有效数字的字符串时， Number 函数恰好返回 NaN 。 因此，条件翻译为“如果 theNumber 是一个数字，那么这样做”。

```javascript
if(!NaN(theNumber)){
    do something
}
```

首先，创建一个计数器绑定来跟踪循环的进度。 然后出现一个 while 循环，通常用一个测试表达式来检查计数器是否已达到其最终值。 在循环体的末尾，更新计数器来跟踪进度。

**跳出循环**

break ：立即跳出loop

continue：循环体中的 continue 语句可以跳出循环体，并进入下一轮循环迭代。

在极少数情况下，绑定名首字母也会大写，比如 Number 函数。这种方式用来表示该函数是构造函数。



**函数**

函数定义是一个常规绑定，其中绑定的值是一个函数。

当控制流遇到这样的语句时，它立即跳出当前函数并将返回的值赋给调用该函数的代码。 不带表达式的 return 关键字，会导致函数返回 undefined 。

**绑定和作用域**

每个绑定都有一个作用域，它是程序的一部分，其中绑定是可见的。 对于在任何函数或块之外定义的绑定，作用域是整个程序 - 即可以在任何地方引用这种绑定。它们被称为全局的。

但是为函数参数创建的，或在函数内部声明的绑定，只能在该函数中引用，所以它们被称为局部绑定。 每次调用该函数时，都会创建这些绑定的新实例。 这提供了函数之间的一些隔离 - 每个函数调用，都在它自己的局部环境中运行，并且通常可以在不知道全局环境中发生的事情的情况下理解。

用 `let` 和 `const` 声明的绑定，实际上是它们的声明所在的块的局部对象，所以如果你在循环中创建了一个，那么循环之前和之后的代码就不能“看见”它。JavaScript 2015 之前，只有函数创建新的作用域，因此，使用 `var` 关键字创建的旧式绑定，在它们出现的整个函数中内都可见，或者如果它们不在函数中，则在全局作用域可见。

每个作用域都可以“向外查看”它周围的作用域。

```javascript
let x = 10;
if(true){
    let y = 8;
    var z = 4;
    console.log(x + y + z); // 22
}
console.log(y + x); // Uncaught ReferenceError: y is not defined
console.log(x + z); // 14
```



当多个绑定具有相同名称时例外 - 在这种情况下，代码只能看到最内层的那个。

```javascript
const halve = function(n){
    return n / 2;
}
let n = 10;
console.log(halve(n)); // 5
console.log(halve(100)); // 50
console.log(n); // 10
```



**嵌套作用域**
JavaScript 不仅区分全局和局部绑定。 块和函数可以在其他块和函数内部创建，产生多层局部环境。

块内可见的绑定集，由这个块在程序文本中的位置决定。 每个局部作用域也可以看到包含它的所有局部作用域，并且所有作用域都可以看到全局作用域。 这种绑定可见性方法称为词法作用域。



**function关键字声明函数**

```javascript
console.log(hello());
function hello(){
    console.log('Hello, world.');
}
```



前面的代码可以执行，即使在函数定义在使用它的代码下面。 函数声明不是常规的从上到下的控制流的一部分。 在概念上，它们移到了其作用域的顶部，并可被该作用域内的所有代码使用。 这有时是有用的，因为它以一种看似有意义的方式，提供了对代码进行排序的自由，而无需担心在使用之前必须定义所有函数。

**箭头函数**

箭头出现在参数列表后面，然后是函数的主体。 它表达了一些东西，类似“这个输入（参数）产生这个结果（主体）”。

如果只有一个参数名称，则可以省略参数列表周围的括号。 如果主体是单个表达式，而不是大括号中的块，则表达式将从函数返回。

```javascript
const square = x => x*x;
```



当一个箭头函数没有参数时，它的参数列表只是一组空括号。

```javascript
const hello = () => {
    console.log('Hello, world.');
}
```

**调用栈**

由于函数在返回时必须跳回调用它的地方，因此计算机必须记住调用发生处上下文。

计算机存储此上下文的地方是调用栈。 每次调用函数时，当前上下文都存储在此栈的顶部。当函数返回时，它会从栈中删除顶部上下文，并使用该上下文继续执行。

计算机存储此上下文的地方是调用栈。 每次调用函数时，当前上下文都存储在此栈的顶部。当函数返回时，它会从栈中删除顶部上下文，并使用该上下文继续执行。

存储这个栈需要计算机内存中的空间。 当栈变得太大时，计算机将失败，并显示“栈空间不足”或“递归太多”等消息。 下面的代码通过向计算机提出一个非常困难的问题来说明这一点，这个问题会导致两个函数之间的无限的来回调用。 相反，如果计算机有无限的栈，它将会是无限的。 事实上，我们将耗尽空间，或者“把栈顶破”。

```javascript
function chicken() {
return egg();
}
function egg() {
return chicken();
}
console.log(chicken() + " came first.");
// → ??
```

**可选参数**

JavaScript 对传入函数的参数数量几乎不做任何限制。如果你传递了过多参数，多余的参数就会被忽略掉，而如果你传递的参数过少，遗漏的参数将会被赋值成 undefined 。

优点是这种行为可以用于使用不同数量的参数调用一个函数。即，可以借助于这种特性来实现函数接收任意数量的参数。

**闭包**

每次调用都会重新创建局部绑定，而且不同的调用不能覆盖彼此的局部绑定。

可以引用封闭作用域中的局部绑定的特定实例，称为闭包。引用来自周围的局部作用域的绑定的函数称为（一个）闭包。 这种行为不仅可以让您免于担心绑定的生命周期，而且还可以以创造性的方式使用函数值。

```javascript
function multiplier(factor) {
return number => number * factor;
}
let twice = multiplier(2);
console.log(twice); // number => number * factor
console.log(twice(5));
// → 10
```

将函数值看作值，包含他们主体中的代码和它们的创建环境。 被调用时，函数体会看到它的创建环境，而不是它的调用环境。

这个例子调用 multiplier 并创建一个环境，其中 factor 参数绑定了 2。 它返回的函数值，存储在 twice 中，会记住这个环境。 所以当它被调用时，它将它的参数乘以 2。

**递归**

调用自己的函数被称为递归函数。 



当用作表达式时， function 关键字可以创建一个函数值。当作为一个语句使用时，它可以用来声明一个绑定，并给它一个函数作为它的值。 箭头函数是另一种创建函数的方式。

理解函数的一个关键方面是理解作用域。 每个块创建一个新的作用域。 在给定作用域内声明的参数和绑定是局部的，并且从外部看不到。 用 var 声明的绑定行为不同 - 它们最终在最近的函数作用域或全局作用域内。