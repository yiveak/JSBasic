<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>作用域</title>
    <script>
        /*
        作用域：变量使用的范围

        全局变量(var)、局部变量(函数内部声明定义的变量不能外部访问，除非函数内定义的变量是隐式全局变量)、全局作用域、局部作用域(函数作用域)

        块级作用域————{}大括号表示块级区，在{}里声明的变量，其使用范围就在{}，即块级作用域
        但JS中无块级块级作用域，其在{}声明的变量，也能在{}之外进行访问获取改变变量的值

        全局变量、局部变量二者的执行效率分析：
        全局变量：只有在浏览器关闭时，才释放内存，即比较占用内存
        局部变量：在调用完函数后，即被销毁

        luckily, ES6中通过let能声明局部变量，即表示该变量只能在当前的{}内使用，外部不能访问
        
        */

        //局部变量(函数内部声明定义的变量不能外部访问) 
        //如果外部尝试访问函数内部的局部变量，则报错Error，且提示该变量is not defined。
        function f1() {
            var str = "我是函数内部通过var定义的变量，是一个局部变量。";
            console.log(str);
        }
        // console.log(str); //返回Error：str is not defined.

        //============================================================================================================
        //隐式全局变量：未通过var声明变量，即为隐式全局变量
        //============================================================================================================

        //函数内声明的隐式全局变量能被外部访问获取，但必须该函数被调用一次？（Yep）
        function f2() {
            str = "我是隐式全局变量。"
            number = 100;
        }
        f2();
        console.log(str);
        console.log(number);

        (function () {
            str = "我是隐式全局变量。"
            // number=100;
        })();
        console.log(str);

        //隐式全局变量可以被删除，而全局变量（即通过var声明的变量）不能被删除
        var num1 = 2;
        num2 = 3;
        delete num1;
        delete num2;
        console.log(typeof num1); //number
        console.log(typeof num2); //undefined
        console.log(num1);
        // console.log(num2); //Error: num2 is not defined
    </script>
</head>

<body>

</body>

</html>